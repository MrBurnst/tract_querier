#!/usr/bin/env python
from pylab import *
import nibabel
import sys
from itertools import izip

import argparse


def main():
    parser = argparse.ArgumentParser(description='Superimposed slices viz')
    parser.add_argument('-s', dest='slices', type=float, nargs='+',
                        help='Slices to show')#, required=True)
    parser.add_argument('-i', dest='base_image', type=str,
                        help='base image to show')#, required=True)
    parser.add_argument('-j', dest='tract_image', type=str, nargs='+',
                        help='tract image to show')#, required=True)
    parser.add_argument('-o', dest='output', type=str,
                        help='output image')#, required=True)
    parser.add_argument('--invert', dest='inverse_order',
                        action='store_true', help='invert the slice order')
    parser.add_argument('--step', dest='step',
                        action='store_true', help='Take the slices as `start end step`')
    parser.add_argument('-t', dest='threshold', type=float, default=0,
                        help='lower threshold of the tract image')
    parser.add_argument('--axis', dest='axis', type=int, default=2,
                        help='axis of the slices')
    parser.add_argument('--mip', dest='mip', action='store_true',
                        help='show maximum intensity projections')

    parser.add_argument('--mm', dest='mm', action='store_true',
                        help='slices are in millimeters')


    parser.add_argument(
        '--displacement', dest='displacement', type=float, default=.1,
        help='displacement between axes between 0. and 1.')
    parser.add_argument(
        '--displacement_direction', dest='displacement_direction', type=str,
        choices=('row', 'col'), default='row',
        help='displacement direction: "row" or "col"')
    parser.add_argument('--color', dest='color', type=str, nargs='+',
                        default='YlOrRd_r', help='Coloring for the tract (default %(default)s)')
    parser.add_argument('--alpha', dest='alpha', type=float, nargs='+', default=1.,
                        help='Alpha for the probability maps')

    parser.add_argument('--print-colors', dest='print_colors', action='store_true',
                        help='Print the list of colormaps')

    args = parser.parse_args()

    if args.print_colors:
        from matplotlib import colors
        maps = [
            cm_ for cm_ in dir(cm)
            if isinstance(getattr(cm, cm_), colors.Colormap)
        ]
        max_length = max(len(cm_) for cm_ in maps) + 3
        str_ = "{:<" + str(max_length) + "}"
        for i in xrange(0, len(maps), 4):
            maps_ = maps[i: i + 4]
            str_line = str_ * len(maps_)
            print str_line.format(*maps_)
        parser.exit(0)

    fig = figure(frameon=False)
    fa_img = nibabel.load(args.base_image)
    fa = fa_img.get_data()

    if isinstance(args.tract_image, str):
        args.tract_image = [args.tract_image]
    tracts = [nibabel.load(tract_image).get_data() for tract_image in args.tract_image]

    if isinstance(args.alpha, float):
        args.alpha = [args.alpha]
    if len(args.alpha) == 1:
        args.alpha *= len(tracts)

    if isinstance(args.color, str):
        args.color = [args.color]
    if len(args.color) == 1:
        args.color *= len(tracts)

    t_colormap = []
    for colormap in args.color:
        t_colormap.append(getattr(cm, colormap))
        t_colormap[-1].set_under(alpha=0)

    fa_cm = cm.gray
    fa_cm.set_under(alpha=0)

    if args.step:
        args.slices = np.linspace(args.slices[0], args.slices[1], (args.slices[1] - args.slices[0]) / args.slices[2])

    if args.mm:
        ras_pos = zeros(4)
        ras_pos[-1] = 1.
        if any(np.diag(np.diag(fa_img.get_affine()[:3, :3])) != fa_img.get_affine()[:3, :3]):
                raise ValueError("Affine matrix is not diagonal, we don't handle this case")
        for i, s in enumerate(args.slices):
            ras_pos[args.axis] = s
            ijk_pos = np.linalg.solve(fa_img.get_affine(), ras_pos)
            args.slices[i] = int(round(ijk_pos[args.axis]))
    else:
            args.slices = [int(s) for s in args.slices]

    for i, y in enumerate(args.slices):
        if args.inverse_order:
            pos = len(args.slices) - 1 - i
        else:
            pos = i

        if args.displacement_direction == 'row':
            fig.add_axes([pos * args.displacement, 0, .5, .5], frameon=False)
        else:
            fig.add_axes([0, pos * args.displacement, .5, .5], frameon=False)
        ax = gca()
        ax.hold(True)

        slices = [slice(None)] * 3
        slices[args.axis] = y
        slices = tuple(slices)

        imshow(fa[slices].T, cmap=fa_cm, vmin=min(1e-10, fa[slices].min), origin=True, interpolation='spline36')
        for tract, colormap in izip(tracts, t_colormap):
            thr = min(tract.max() - 1e-10, args.threshold)
            if args.mip:
                tract_slice = tract.max(args.axis).T
            else:
                tract_slice = tract[slices].T
            imshow(
                tract_slice, cmap=colormap,
                vmin=thr, vmax=tract.max(), origin=True, interpolation='gaussian'
            )
        xticks([])
        yticks([])
        ax.hold(False)
    savefig(args.output, bbox_inches='tight', transparent=True, pad_inches=0)


if __name__ == '__main__':
    sys.exit(main())
